<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <title>PYTHON网络编程</title>
  <meta name="description" content="pyhon进阶：导出为pdf可能每页内容可能有点乱重要为🍅次重要为🍎思考为🥔没有标示为普普通通linux">
  <meta name="author" content="Wei Wang">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="PYTHON网络编程">
  <meta name="twitter:description" content="pyhon进阶：导出为pdf可能每页内容可能有点乱重要为🍅次重要为🍎思考为🥔没有标示为普普通通linux">
  
  <meta property="og:type" content="article">
  <meta property="og:title" content="PYTHON网络编程">
  <meta property="og:description" content="pyhon进阶：导出为pdf可能每页内容可能有点乱重要为🍅次重要为🍎思考为🥔没有标示为普普通通linux">
  
  <link rel="icon" type="image/png" href="/assets/images/favicon.png" />
  <link href="/assets/images/favicon.png" rel="shortcut icon" type="image/png">
  
  <link rel="stylesheet" href="/css/main.css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="canonical" href="http://localhost:4000/2018/12/Pyhton-%E9%AB%98%E7%BA%A7/">
  <link rel="alternate" type="application/rss+xml" title="Crise-Genius" href="http://localhost:4000/feed.xml">
  
  <meta name="google-site-verification" content="1-1ZlHoRvM0T2FqPbW2S-qLgYXN6rsn52kErlMPd_gw" />
  
</head>


  <body>

    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>
    
    <header class="panel-cover panel-cover--collapsed" style="background-image: url('/assets/images/background-cover.jpg')">
  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/#blog" title="前往 Crise-Genius 的主页" class="blog-button"><img src="/assets/images/avatar.jpg" width="80" alt="Crise-Genius logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/#blog" title="link to homepage for Crise-Genius" class="blog-button">Crise-Genius</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">站在巨人的肩膀上 We Will Be Giants</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">嗨，我是梁英健(@Crise-LYJ)，我会成为一名出色的开发者。</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        
        
        <p class="panel-cover__description"><a href="https://github.com/CriseLYJ" target="_blank">Here Is My Github</a></p>
        
        
        <div class="navigation-wrapper">
          <div>
            <nav class="cover-navigation cover-navigation--primary">
              <ul class="navigation">
                <li class="navigation__item"><a href="/#blog" title="Visit blog" class="blog-button">Blog</a></li>
                
                  <li class="navigation__item"><a href="https://criselyj.github.io/" target="_blank" title="My Projects">Projects</a></li>
                
              </ul>
            </nav>
          </div>
          
          <div><nav class="cover-navigation navigation--social">
  <ul class="navigation">

  
  <!-- Weibo -->
  <li class="navigation__item">
    <a href="http://weibo.com/Github每日开源KYZG" title="@Github每日开源KYZG 的微博" target="_blank">
      <i class='social fa fa-weibo'></i>
      <span class="label">Weibo</span>
    </a>
  </li>
  

  
  <!-- Github -->
  <li class="navigation__item">
    <a href="https://github.com/CriseLYJ" title="@CriseLYJ 的 Github" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>
  
  
  
  <!-- Twitter -->
  <li class="navigation__item">
    <a href="http://twitter.com/CriseLYJ" title="@CriseLYJ" target="_blank">
      <i class='social fa fa-twitter'></i>
      <span class="label">Twitter</span>
    </a>
  </li>
  

  
  <!-- Google Plus -->
  <li class="navigation__item">
    <a href="https://plus.google.com/1998lyjvip@gmail.com" rel="author" title="Google+" target="_blank">
      <i class='social fa fa-google-plus-square'></i>
      <span class="label">Google Plus</span>
    </a>
  </li>
  

  <!-- RSS -->
  <li class="navigation__item">
    <a href="/feed.xml" rel="author" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>

  
  <!-- Email -->
  <li class="navigation__item">
    <a href="mailto:1148995537@qq.com" title="Contact me">
      <i class='social fa fa-envelope'></i>
      <span class="label">Email</span>
    </a>
  </li>
  

  </ul>
</nav>
</div>
        </div>
      </div>
    </div>
    
    
    <div class="panel-cover--overlay cover-read"></div>
    
  </div>
</header>


    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <div class="post-meta">
      <time datetime="2018-12-22 17:11:11 +0800" itemprop="datePublished" class="post-meta__date date">2018-12-22</time> &#8226; <span class="post-meta__tags tags">python 网络编程 多线程/进程/协程</span>
    </div>
    <h1 class="post-title">PYTHON网络编程</h1>
  </header>

  <section class="post">
    <h1 id="pyhon进阶">pyhon进阶：</h1>
<h3 id="导出为pdf可能每页内容可能有点乱">导出为pdf可能每页内容可能有点乱</h3>
<h3 id="重要为">重要为🍅</h3>
<h3 id="次重要为">次重要为🍎</h3>
<h3 id="思考为">思考为🥔</h3>
<h3 id="没有标示为普普通通">没有标示为普普通通</h3>
<hr />
<h1 id="linux">linux</h1>

<h2 id="liux操作系统">liux操作系统</h2>

<ol>
  <li>操作系统（Operation System，OS）是管理硬件和控制软件运行的计算机程序, 是直接运行在“裸机”上的系统软件, 任何其他软件都必须在操作系统的支持下才能运行.</li>
  <li>主要作用是向下控制硬件向上支持软件的运行，具有承上启下的作用.</li>
  <li>大量的软件都直接依赖于操作系统的支持.</li>
  <li>Linux 在服务器领域的应用是其重要分支.相比 Windows Server, Linux 具有免费、稳定、高效的特点. Linux 在服务器领域的占用率大大高于 Windows Server.</li>
</ol>

<h3 id="linux诞生">linux诞生</h3>
<ul>
  <li>
    <p>1973 年初, 美国的 Thompson 和 Ritchie 使用 C 语言开发了 Unix 操作系统</p>

    <p><img src="/assets/mdimg/unix之父.png" alt="" /></p>
  </li>
  <li>
    <p>由于 Unix 版权问题, 大学不能再使用 Unix 源代码. 荷兰的 Andrew S. Tanenbaum (塔能鲍姆) 教授为了教学于 1987 年自行开发与 UNIX 兼容的 Minix 操作系统.</p>

    <p><img src="/assets/mdimg/塔能鲍姆.jpg" alt="" /></p>
  </li>
  <li>
    <p>1991 年, 林纳斯(Linus) 就读于赫尔辛基大学期间, 受到 Minix 的影响, 并在 Minix 操作平台建立了一个新的操作系统的内核, 他把它叫做 Linux.</p>

    <p><img src="/assets/mdimg/Linus.jpg" alt="" /></p>
  </li>
</ul>

<h4 id="内核">内核</h4>
<ul>
  <li>概念：
    <ul>
      <li>
        <p>内核, 是一个操作系统的核心. 是基于硬件的第一层软件扩充, 提供操作系统的最基本的功能, 是操作系统工作的基础.</p>
      </li>
      <li>
        <p>它负责管理系统的进程、内存、设备驱动程序、文件和网络系统，决定着系统的性能和稳定性.</p>
      </li>
    </ul>

    <p><img src="/assets/mdimg/Linux内核.png" alt="" /></p>
  </li>
</ul>

<h3 id="linux文件操作">🍎linux文件操作</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>touch(文件名) :创建文件
rm (文件名)：删除文件
rm -r (文件夹名称) ：可以删除空的文件夹，也可以删除非空的文件夹
mkdir （文件夹名称）:创建文件夹
rmdir （文件夹名称）:删除文件夹 ：只能删除空的文件夹（不过用的较多的还是rm -r)
cp (要复制的文件路径) (要复制到的位置) ：从一个目录复制一个文件到另外一个目录
cp - i (要复制的文件路径) (要复制到的位置) ：复制的时候如果目录存在，会打印提示信息
clear :清空终端内容
tree :树状显示文件夹中的内容
mv (文件夹路径)(要移动到的路径) ：将一个文件夹移动到另外一个文件夹
mv (原文件件名)(要改为的文件名) ：重命名 ：如果本地有同名文件，将会直接替换
cd ~ : 回到家目录
cd - : 切换到上一次所在的目录
命令 --help : 查看帮助文件
man 命令 ： 帮助文档
	
$ tree -a          //显示所有文件和目录。
$ tree -d         //显示目录名称而非内容
$ tree -L 2      //这个命令是比较实用的，后面的数字2代表几层
</code></pre></div></div>

<ul>
  <li>在当前目录的文件夹中创建一个文本文档
    <ul>
      <li>touch ./A/a.txt</li>
    </ul>
  </li>
  <li>将一个文件夹复制到另外一个文件夹
    <ul>
      <li>cp -r A B</li>
    </ul>
  </li>
</ul>

<h3 id="扩展的命令">扩展的命令😢</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir .（文件夹名称） :将会创建一个隐藏的文件夹
cd .(文件夹名称) ： 将会进入隐藏文件夹 
ls -a ：可以显示所有文件，包括隐藏的文件
ls -l ：可以查看文件的信息 前缀为d是文件夹 前缀为-是文件 前缀后面三个为用户权限，后面三个为不再这个组的权限
ll ：同上，还可以显示隐藏信息（mac不可用）
l -al or l -la : 同上（mac使用）
mkdir -p (多级文件夹) ：创建多级文件夹
rm -f (文件名称) : 删除文件的时候如果文件不存在不提示
cp -v :显示复制信息
mv -i ：显示提示信息
</code></pre></div></div>

<h3 id="重定向">重定向：</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ls &gt; a.txt : 把当前目录下的信息输出到一个文件中（原先输输出到屏幕）
    cat a.txt : 查看这个文件中的内容
    ls &gt;&gt; a.txt : 把内容追加到一个文件中
    more a.txt : 同上
</code></pre></div></div>

<h3 id="链接">链接：</h3>

<ul>
  <li>linux可以创建快捷方式
    <ul>
      <li>软链接文件
        <ul>
          <li>ln -s 文件名 快捷方式名</li>
          <li>两个指向同一个内存：在其中一个删除两个都会变</li>
          <li>删除其中一个，另外一个内容会被清空</li>
          <li>b 文件直接指向 a 文件</li>
        </ul>
      </li>
      <li>硬链接文件
        <ul>
          <li>ln 文件名 新文件名</li>
          <li>就是python中的引用</li>
          <li>只能链接文件，不能链接文件夹</li>
          <li>更改的时候两个都会变，删除的时候没被删除的不变</li>
          <li>b 指向的是 a 的引用</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="grep文件内容查询">grep文件内容查询：</h3>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>grep 'a' a.txt ：在a.txt中查找 a 
	
grep -n 'a' a.txt : 显示行号
	
grep -n '^a' a.txt : 查找以a开头的数据
	
grep -n 'a$' a.txt : 查找以a结尾的数据
	
grep -n '[abc]' a.txt : 查找包含中括号数据中的内容的数据=(a或者b或者c)
[]中括号就是或者的意思
	
grep -n 't.t' a.txt : 匹配任意一个字符
🥔. 点就代表拿个字符
</code></pre></div></div>

<h3 id="管道">管道</h3>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ls | grep 'a.txt' :将文件存到管道中，然后使用正则进行过滤
</code></pre></div></div>
<h3 id="相对路径-光标所处的位置">相对路径 ：光标所处的位置</h3>

<h3 id="绝对路径根目录开始">绝对路径：根目录开始</h3>

<h2 id="linux文件操作2">linux文件操作2</h2>

<h3 id="find文件查询">find文件查询</h3>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>需求：grep只能查询当前目录第一级
find是整个目录的遍历
</code></pre></div></div>

<h3 id="find---name-atxt-find-查询的目录名-查询的方式-匹配的正则">find ./ -name ‘a.txt’ (find 查询的目录名 查询的方式 匹配的正则)</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* 代表0个或者多个任意字符
    find ./ -name '*.txt'
? 代表任意一个字符(没有排序功能)
    find ./ -name 'day0?'
[] 或者
    find ./ -name '[ab].txt'(a.txt或者b.txt)
</code></pre></div></div>

<h3 id="压缩-解压缩">压缩 解压缩</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- c 生成档案文件
- v 显示压缩过程
- f 不可省略
- x 解压缩
- z 代表gz格式
</code></pre></div></div>

<h3 id="gz格式">gz格式</h3>

<h3 id="打包tar--cvf-girltar-girl">打包：tar -cvf girl.tar girl</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 压缩：gzip girl.tar
 一键压缩：tar -zcvf girl.tar.gz girl（压缩名字 文件夹名称）
 简洁版压缩：tar -zcvf girl.tar girl(同样可以解压，但是解压很费劲，不提倡)
 解压缩：tar -zxvf girl.tar.gz
 解压到特定的目录：tar -zxvf girl.tar.gz -C B
</code></pre></div></div>

<h3 id="bz2格式">bz2格式</h3>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>压缩：tar -jcvf girl.tar.bz2 girl
解压：tar -jxvf girl.tar.bz2
</code></pre></div></div>

<h3 id="zip格式压缩大小会低很多但是windows可以兼容">zip格式(压缩大小会低很多，但是windows可以兼容)</h3>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>压缩：zip -r girl.zip girl(压缩文件夹，如果不加-r压缩之后会是一个空包)
解压：unzip girl.zip
</code></pre></div></div>

<h3 id="修改文件权限">修改文件权限</h3>

<h4 id="-ugoa-含义">[ u/g/o/a ]含义</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>u user 表示该文件的所有者
g grop 用户组
o other 表示其他以外的人
a all 所有人
w write 写
r read 读
x excute 执行
+ 增加权限
- 撤销权限
= 设定权限 (相当于变量的赋值)
</code></pre></div></div>

<h4 id="chmod-修改权限字母法">chmod 修改权限（字母法）</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>chmod u+x (文件名)
</code></pre></div></div>

<h4 id="chmod-修改权限-数字法">chmod 修改权限 （数字法）</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>r = 4
w = 2
x = 1
没权限=0
所有权限 = 7
chmod 777 （文件名）所有组，所有权限
chmod 700  (文件名) 用户组，所有权限
---------------------------------
🍅推荐字母法
</code></pre></div></div>

<h3 id="其他">其他</h3>

<h4 id="查看命令的位置">查看命令的位置</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>which 命令 ：查看命令所在位置
</code></pre></div></div>
<h4 id="最高权限">最高权限</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo -s
exit 退出权限
</code></pre></div></div>
<h4 id="当前用户">当前用户</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>whoami
</code></pre></div></div>
<h4 id="更改密码">更改密码</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo passwd 用户名
</code></pre></div></div>
<h4 id="查看所有用户">查看所有用户</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>who
</code></pre></div></div>
<h4 id="format-恢复">format 恢复</h4>

<h4 id="远程">远程</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scp 从哪里复制 复制到哪里
文件夹加上-r
</code></pre></div></div>

<h1 id="网络编程">网络编程</h1>

<h3 id="vim扩展">🥔vim扩展：</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim -On能同时打开多个文件
</code></pre></div></div>

<ul>
  <li>理论
    <ul>
      <li>一些相互连接的、以共享资源为目的、自治的计算机的集合.</li>
    </ul>
  </li>
</ul>

<h3 id="ip地址">IP地址</h3>

<ul>
  <li>IP 地址是指互联网协议地址（英语：Internet Protocol Address，又译为网际协议地址）, 是 IP Address 的缩写. IP 地址是 IP 协议提供的一种统一的地址格式.</li>
  <li>🥔🥔理解
    <ul>
      <li>IP 地址被用来给 Internet 上的电脑一个编号。</li>
    </ul>
  </li>
  <li>查看和设置IP地址：
    <ul>
      <li>linux下使用ifconfig命令来查看和配置网卡的IP地址</li>
      <li>windows下使用ipconfig</li>
    </ul>
  </li>
  <li>检查网络的连通性
    <ul>
      <li>通过ping命令查看网络的连通性</li>
    </ul>
  </li>
</ul>

<h3 id="端口">端口</h3>

<ul>
  <li>端口的作用
    <ul>
      <li>端口是操作系统分配给网络应用程序的编号, 当接收到数据之后, 操作系统会根据编号来将数据转发到对应编号的应用程序.</li>
      <li>网络程序必须要有端口号.</li>
    </ul>
  </li>
  <li>端口号
    <ul>
      <li>端口号就是标识端口的一个编号. 在 Linux 系统中, 端口号在 0-65535 之间. 端口号不是随意使用的, 而是按照一定的规定(操作系统规定)进行分配. 端口号分:
        <ol>
          <li>知名端口号。</li>
          <li>动态端口号.</li>
        </ol>
      </li>
    </ul>
  </li>
  <li>查看端口号
    <ul>
      <li>
        <table>
          <tbody>
            <tr>
              <td>用 netstat -an</td>
              <td>grep “:8080” 检验本机各端口的网络连接情况.</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>用 lsof -i [tcp/udp]:8080 列出当前系统端口所对应的程序.</li>
    </ul>
  </li>
</ul>

<h3 id="ip端口总结">IP，端口总结：</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>IP 用于标示网络设备的唯一标识
Port 网络应用的唯一标识
</code></pre></div></div>

<h2 id="udp">UDP</h2>

<ul>
  <li>概念
    <ul>
      <li>UDP 英文全拼 (User Datagram Protocol) 简称用户数据报协议， 它是无连接的、不可靠的网络传输协议.</li>
    </ul>
  </li>
</ul>

<h3 id="udp-特点">UDP 特点</h3>
<ul>
  <li>查看哪些端口被占用： netstat -n</li>
  <li>
    <ol>
      <li>无连接</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>资源开销小</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>传输速度快</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>udp每个数据包最大是64K</li>
    </ol>
  </li>
</ul>

<h3 id="udp优缺点">UDP优缺点</h3>
<ol>
  <li>优点:
    <ul>
      <li>传输速度快</li>
      <li>不需要连接，资源开销小</li>
    </ul>
  </li>
  <li>缺点:
    <ul>
      <li>传输数据不可靠，容易丢数据包</li>
      <li>没有流量控制，当对方没有及时接收数据，发送方一直发送数据会导致缓冲区数据满了，电脑出现卡死情况，所有接收方需要及时接收数据。</li>
    </ul>
  </li>
</ol>

<h3 id="socket">socket</h3>
<ul>
  <li>理论：
    <ul>
      <li>socket(简称 套接字) 是进程间通信一个工具，它能实现把数据从一方传输到另外一方，完成不同电脑上进程之间的通信， 它好比数据的搬运工。</li>
      <li>🥔🥔就是实现不同进程之间的通信</li>
    </ul>
  </li>
</ul>

<h3 id="udp网络程序流程">UDP网络程序流程</h3>
<ol>
  <li>创建udp套接字(socket.socket(socket.AF_INET, socket.SOCK_DGRAM))</li>
  <li>绑定端口：bind()</li>
  <li>发送/接收数据（发送：sendto().  接收:recvfrom(一次接收多少字节).）</li>
  <li>关闭套接字	:close()</li>
</ol>

<h3 id="初始化">初始化</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">（代表</span><span class="n">ipv4</span><span class="p">:</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span> <span class="p">,</span> <span class="err">代表</span><span class="n">udp</span><span class="p">:</span><span class="n">socket</span><span class="o">.</span><span class="n">SOCKET_DGRAM</span><span class="err">）</span>
</code></pre></div></div>

<h3 id="udp网络程序流程-1">UDP网络程序流程</h3>
<ul>
  <li>UDP网络程序发送数据不需要建立数据</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>打包：encode
拆包：decode
</code></pre></div></div>

<h3 id="udp广播">UDP广播</h3>
<ul>
  <li>设置允许广播</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">udp_sock</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span><span class="n">socket</span><span class="o">.</span><span class="n">SO_BROADCAST</span><span class="p">,</span><span class="bp">True</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="tcp">TCP</h2>

<h4 id="特点">特点</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>有连接
可靠传输：采用应答机制，必须对象给响应才能正常通信
连接一对一，不适用广播的应用程序
超时重新传
错误校验：验证数据包
流量控制和阻塞管理：避免主机发送的过快，客户机收不过来
首先需要校验
</code></pre></div></div>

<h3 id="优点">优点</h3>
<ul>
  <li>可靠：可以得出其他特点</li>
  <li>稳定</li>
</ul>

<h3 id="缺点">缺点</h3>
<ul>
  <li>传输速度慢</li>
  <li>占用系统资源高</li>
</ul>

<h3 id="应用场景">应用场景</h3>
<ul>
  <li>网站开发，保证数据可靠</li>
  <li>文件传输</li>
</ul>

<h3 id="tcp-以数据流形式发送代码">TCP 以数据流形式发送代码</h3>

<h3 id="tcp流程客户端">TCP流程：客户端</h3>
<ol>
  <li>初始化：socket () ：</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">（代表</span><span class="n">ipv4</span><span class="p">:</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span> <span class="p">,</span> <span class="err">代表</span><span class="n">tcp</span><span class="p">:</span><span class="n">socket</span><span class="o">.</span><span class="n">SOCKET_STREAM</span><span class="err">）</span>
</code></pre></div></div>
<ol>
  <li>连接: connect()</li>
  <li>发送：send（）</li>
  <li>接收：recv（）</li>
  <li>关闭：close（）</li>
</ol>

<p><img src="/assets/mdimg/屏幕快照 2018-12-18 上午10.49.04.png" alt="" /></p>

<p><img src="/assets/mdimg/屏幕快照 2018-12-18 上午9.21.27.png" alt="" /></p>

<h3 id="tcp流程服务器端">TCP流程：服务器端</h3>

<h4 id="初始化-1">初始化：</h4>
<ol>
  <li>初始化：socket () ：两个参数</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="n">ipv4</span><span class="p">:</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="err">代表</span><span class="n">tcp</span><span class="p">:</span><span class="n">socket</span><span class="o">.</span><span class="n">SOCKET_STREAM</span><span class="p">)</span>
</code></pre></div></div>

<ol>
  <li>绑定端口：bind ()</li>
  <li>监听：等待:listen（）：128代表系象征意义，现在按内存数来算</li>
  <li>接听：同意接收：accept（）返回一个元组：cilent:给客户端服务的对象  address：客户端地址</li>
</ol>

<h4 id="传输">传输：</h4>

<ol>
  <li>接收：recv（）</li>
  <li>发送：send（）</li>
  <li>关闭：close（）</li>
</ol>

<h4 id="重新使用端口循环发送与接收">重新使用端口：循环发送与接收</h4>

<p><img src="/assets/mdimg/屏幕快照 2018-12-18 下午2.37.25.png" alt="" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 重新使用端口，这个一定要在绑定之前写
</span><span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span><span class="n">socket</span><span class="o">.</span><span class="n">SO_REUSEADDR</span><span class="p">,</span><span class="bp">True</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="服务器端与客户端总结">🍅服务器端与客户端：总结</h4>
<ol>
  <li>服务器端需要绑定端口</li>
  <li>客户端不需要进行端口绑定</li>
  <li>如果客户端关闭了，那么我们服务器会接收空的信息NONE</li>
</ol>

<h3 id="三次握手">🍎🍎三次握手：</h3>
<h4 id="标志位">标志位</h4>
<ol>
  <li>SYN：表示连接请求</li>
  <li>ACK：标示确认</li>
  <li>FIN：标示关闭连接</li>
  <li>Seq：表示报文序号</li>
  <li>ack：表示序号</li>
</ol>

<p><img src="/assets/mdimg/屏幕快照 2018-12-18 下午3.20.08.png" alt="" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tcp是可靠的传输，因为客户端在连接服务器端时使用三次握手，三次握手分别客户端与服务器端都做了一次数据的确定，保证客户端跟服务器端是通的
作用：
	分别三次确认！！！
</code></pre></div></div>

<h3 id="四次挥手">四次挥手：</h3>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>客户端关闭的时候做了四次挥手，
保证关闭的可靠性
客户端做了一次关闭的请求
服务器资源处理完以后也做了一个关闭的请求
也进行一次确认
双方都确认以后才会关闭
</code></pre></div></div>

<p><img src="/assets/mdimg/屏幕快照 2018-12-18 下午3.50.52.png" alt="" /></p>

<h4 id="作业">作业：</h4>

<p><img src="/assets/mdimg/屏幕快照 2018-12-18 下午3.06.30.png" alt="" /></p>

<h4 id="聊天器多任务版">聊天器多任务版</h4>

<h1 id="多线程进程协程">🍅多线程/进程/协程</h1>
<h2 id="多线程">多线程</h2>
<h3 id="概念">概念：</h3>
<ul>
  <li>同一时间执行多个任务，每个人物可以理解成层现实生活中干的每个活</li>
  <li>函数后加括号是引用函数的值</li>
  <li>不加括号是引用函数</li>
  <li>target:对象</li>
  <li>代码：</li>
</ul>

<p><img src="/assets/mdimg/屏幕快照 2018-12-18 下午4.20.40.png" alt="" /></p>

<h3 id="线程的步骤">线程的步骤：</h3>
<ol>
  <li>导入模块</li>
  <li>加入任务</li>
  <li>开启任务</li>
</ol>

<h3 id="理解">🥔🥔理解：</h3>

<p><img src="/assets/mdimg/屏幕快照 2018-12-18 下午4.48.01.png" alt="" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>如果主线程堵塞，所有线程都会堵住，如果副线程堵塞，对其他线程不影响
</code></pre></div></div>
<ul>
  <li>代码理解：</li>
</ul>

<p><img src="/assets/mdimg/屏幕快照 2018-12-18 下午4.50.50.png" alt="" /></p>

<h3 id="传参">传参</h3>
<ul>
  <li>args:元组</li>
  <li>kwargs：字典</li>
</ul>

<p><img src="/assets/mdimg/屏幕快照 2018-12-18 下午5.09.51.png" alt="" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 传元组参数顺序必须一样
- 传字典时参数名必须一致
</code></pre></div></div>

<h3 id="拓展函数专题">拓展：函数专题</h3>
<ol>
  <li><img src="/assets/mdimg/屏幕快照 2018-12-18 下午5.15.47.png" alt="" /></li>
</ol>

<ul>
  <li>打印出来的是引用</li>
</ul>

<p><img src="/assets/mdimg/屏幕快照 2018-12-18 下午5.16.30.png" alt="" /></p>

<ol>
  <li><img src="/assets/mdimg/屏幕快照 2018-12-18 下午5.17.14.png" alt="" /></li>
</ol>

<ul>
  <li>调用</li>
</ul>

<h3 id="线程注意点">线程注意点</h3>
<ul>
  <li>
    <p>线程是无序的</p>
  </li>
  <li>
    <p>主线程要等所有的子线程结束才结束</p>
  </li>
  <li>
    <p>主线程死了，所有的子线程也会结束</p>
  </li>
  <li>
    <p>线程之间共享全局变量</p>
  </li>
  <li>
    <p>多线程中，如果其中哪一个线程出错，其他线程不会停止</p>
  </li>
</ul>

<p><img src="/assets/mdimg/屏幕快照 2018-12-20 上午10.55.17.png" alt="" /></p>

<p><img src="/assets/mdimg/屏幕快照 2018-12-20 上午11.03.15.png" alt="" /></p>

<h3 id="守护线程理解">🥔🥔守护线程理解：</h3>
<ul>
  <li>主线结束即所有线程结束</li>
  <li>当有多个子线程，但不是所有的字线程都是守护的，所有线程要等没有守护的线程结束才会结束</li>
  <li>当有多个子线程的时候，没有守护的线程结束（程序结束），守护的线程也会结束</li>
</ul>

<h3 id="共享全局变量问题分析">共享全局变量问题分析</h3>

<ul>
  <li>线程共享全局变量会出错</li>
  <li>
    <p>原理：</p>
  </li>
  <li>计算num += 1：</li>
  <li>总共三步：</li>
  <li>cpu去内存中获取num的值</li>
  <li>cpu对num值计算加1： 🍅此时内存中的值还没有变化</li>
  <li>cpu把计算完的值重新赋值给内存
    <h3 id="拓展">拓展：</h3>
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  * cpu执行没有顺序
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="答案">🍅答案：</h3>

<p><img src="/assets/mdimg/屏幕快照 2018-12-20 下午3.05.23.png" alt="" /></p>

<h3 id="共享全局变量问题解决">🍅共享全局变量问题解决</h3>

<h3 id="互斥锁同性相斥">互斥锁：同性相斥</h3>

<p><img src="/assets/mdimg/屏幕快照 2018-12-20 下午3.11.38.png" alt="" /></p>

<ol>
  <li>将这三步锁上，形成一个对象</li>
  <li>判断多个线程之间对象是否相同</li>
  <li>如果相同，就把其他的都阻塞住</li>
  <li>当运行完之后，就会解锁，执行其他线程</li>
</ol>

<h3 id="总结就是产生多个相同的对象在当前线程没结束之前所有相同对象的进程都会被锁住">🥔🥔总结：就是产生多个相同的对象，在当前线程没结束之前，所有相同对象的进程都会被锁住！</h3>

<h3 id="添加互斥锁过程">添加互斥锁过程：</h3>
<ol>
  <li>创建互斥锁</li>
  <li>lock = threading.Lock()</li>
  <li>加锁:加在需要加锁的代码上面和后面</li>
  <li>加锁：Lock.acquire()&lt;——代码段——&gt;lock.release()：解锁</li>
  <li>解锁</li>
  <li>lock.release()</li>
</ol>

<h4 id="需要互斥的代码都必须加锁而且必须是同一把锁">需要互斥的代码都必须加锁：而且必须是同一把锁</h4>
<ul>
  <li>如果不是同一把锁，同样会出错
<img src="/assets/mdimg/屏幕快照 2018-12-20 下午3.47.05.png" alt="" /></li>
</ul>

<h3 id="死锁是一个bug">死锁：是一个BUG</h3>

<h4 id="概念-1">概念：</h4>
<ul>
  <li>其中一个线程挂了：cpu无法结束判断当前进程已经结束，被锁住出不来了</li>
  <li>实例代码：
<img src="/assets/mdimg/屏幕快照 2018-12-20 下午3.50.44.png" alt="" /></li>
</ul>

<h4 id="解决方法">解决方法</h4>
<ul>
  <li>🍅🍅在退出之前解锁</li>
</ul>

<h3 id="自定义线程">自定义线程</h3>
<ol>
  <li>创建一个类</li>
  <li>继承多线程类</li>
  <li>🍅🍅 重写run方法：方法名必须是run
<img src="/assets/mdimg/屏幕快照 2018-12-20 下午4.15.10.png" alt="" /></li>
</ol>

<h3 id="自定义线程传参">自定义线程传参：</h3>

<p><img src="/assets/mdimg/屏幕快照 2018-12-20 下午4.37.08.png" alt="" /></p>

<h3 id="并行与并发">并行与并发</h3>
<h4 id="线程是cpu执行调度的单位">线程是cpu执行（调度）的单位</h4>
<ul>
  <li>并发
    <ul>
      <li>看上去像同时发生的（但是并不是同时运行的）</li>
    </ul>
  </li>
  <li>并行
    <ul>
      <li>🍎要有硬件支持：多核</li>
      <li>就是真的同时发生的</li>
    </ul>
  </li>
  <li>任务数大于核数也是并发
    <ul>
      <li>🥔🥔比如双核，执行三个线程，也是并发</li>
    </ul>
  </li>
</ul>

<h3 id="线程有bug">线程有BUG：</h3>
<ul>
  <li>如果只用线程做不到并行：不能充分的利用cpu</li>
  <li>gil问题 全局 解释器锁</li>
  <li>🥔🥔所以要去学习进程：进程可以充分利用cpu</li>
</ul>

<h3 id="多线程最根本的问题">多线程最根本的问题</h3>

<ul>
  <li>🍅就是解决了主线程被阻塞的问题</li>
  <li>🥔当主线程在被阻塞时，而又需要继续跑多线程，那么就需要多线程来解决问题</li>
  <li>🥔哪个方法堵住了，就在哪加线程</li>
</ul>

<h2 id="进程">进程</h2>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>单词收集：
	current：当前的
</code></pre></div></div>

<h3 id="可以充分利用cpu">可以充分利用cpu</h3>
<ul>
  <li>🍅gil:全局解释器锁</li>
  <li>进程：通俗理解一个运行的程序或者软件，进程时操作系统的资源分配的基本单位</li>
  <li>线程是cpu进行调度的单位</li>
  <li>🍅：线程做任务，进程用来申请资源（内存）</li>
  <li>🥔干活的是线程，申请资源的是进程</li>
  <li>线程是cpu进行调度的单位</li>
  <li>程序只要开启就有一个进程，进程内包含一个线程</li>
  <li>程序验证：</li>
</ul>

<p><img src="/assets/mdimg/屏幕快照 2018-12-21 上午10.06.28.png" alt="" /></p>

<p><img src="/assets/mdimg/屏幕快照 2018-12-21 上午10.07.00.png" alt="" /></p>

<h3 id="怎么写">怎么写：</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 导入
</span><span class="kn">import</span> <span class="nn">multiprocessing</span> 

<span class="c1">#加入任务
</span><span class="n">A</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="err">函数名</span><span class="mi">1</span><span class="err">）</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="err">函数名</span><span class="mi">2</span><span class="err">）</span>

<span class="c1"># 开启
</span><span class="n">A</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">B</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</code></pre></div></div>

<h3 id="传参与多线程一样">传参：与多线程一样</h3>
<ul>
  <li>args：传元组</li>
  <li>kwargs：传字典</li>
</ul>

<h3 id="进程的状态">进程的状态</h3>

<p><img src="/assets/mdimg/屏幕快照 2018-12-21 上午10.10.30.png" alt="" /></p>

<ul>
  <li>调度
    <ul>
      <li>调用进程里面的线程</li>
    </ul>
  </li>
  <li>进程缺陷
    <ul>
      <li>开了多个进程后可能会造成资源浪费</li>
    </ul>
  </li>
</ul>

<h3 id="每一个进程中第一个线程都是主线程">每一个进程中，第一个线程都是主线程</h3>

<h3 id="进程全局变量问题">🍎进程全局变量问题</h3>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 进程之间不共享全局变量  - 🍅🍅进程如果想要共享全局变量
* 队列：操作系统提供的一块公共的区域，使进程可以在队列中进行通讯
* 进程一将数据存入队列中，进程二可以直接从队列中取出来

![](/assets/mdimg/屏幕快照 2018-12-21 上午10.50.15.png)
</code></pre></div></div>

<h4 id="队列">🍎队列</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 队列是先进先出
2. 取完数据，队列中的数据就没了
3. 如果添加超过了定义的最大的数据量，会进行阻塞，不会报错
4. 如果队列中的数据为空，那么再取会进行阻塞，不会报错
5. queue.qsize():判断队列中还有多少数据
</code></pre></div></div>

<ul>
  <li>
    <p>代码实现</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">#导入
</span>  <span class="kn">import</span> <span class="nn">multiprocessing</span>
	
  <span class="c1"># 定义一个队列
</span>  <span class="c1"># 最大放三个数据
</span>  <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Queue</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># 如果括号内不写数据，默认为最大值
</span>	
  <span class="c1"># 放数据
</span>  <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s">"2"</span><span class="p">)</span>
  <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
	
  <span class="c1"># 判断队列中还有多少数据
</span>  <span class="k">print</span><span class="p">(</span><span class="s">"个数"</span><span class="p">,</span><span class="n">queue</span><span class="o">.</span><span class="n">qsize</span><span class="p">())</span>
	
  <span class="c1"># 取数据
</span>  <span class="k">print</span><span class="p">(</span><span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
  <span class="k">print</span><span class="p">(</span><span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
  <span class="k">print</span><span class="p">(</span><span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
	
  <span class="c1"># 打印出的数据
</span>  <span class="o">&gt;&gt;</span> <span class="err">个数</span> <span class="mi">3</span>
  <span class="o">&gt;&gt;</span> <span class="mi">1</span>
  <span class="o">&gt;&gt;</span> <span class="mi">2</span>
  <span class="o">&gt;&gt;</span> <span class="mi">3</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="队列有bug">队列有BUG</h3>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> get_nowait/put_nowait：不等待直接放进去/不等待直接放进去
 如果不能放数据了直接报错
 如果没有数据了再取直接报错
 🍅这些方法有bug，尽量不要去用
</code></pre></div></div>

<h3 id="进程池pool">进程池pool</h3>
<h4 id="概念-2">概念：</h4>
<ul>
  <li>池子里面放的是进程，进程池会根据任务执行情况自动创建进程，而且尽量少创建进程，合理利用进程池中的进程完成多任务</li>
  <li>🥔通俗的讲就是重复的利用进程</li>
  <li>减少我们的资源</li>
</ul>

<h3 id="代码">代码：</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 进程池的作用就是重复使用进程
# 循环创建是个进程做事情
# 复制
# 如果不是用进程池，每个进程都不重复
</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="kn">from</span> <span class="nn">gevent</span> <span class="kn">import</span> <span class="n">os</span>


<span class="k">def</span> <span class="nf">copy</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"copy-----"</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">())</span>  <span class="c1"># 查看当前进程pid
</span>    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># 创建10个进程做事情
</span>    <span class="c1"># 最大三个线程同时运行
</span>    <span class="n">pool</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">temp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="c1"># multiprocessing.Process(target=copy).start()
</span>        <span class="c1"># 加入任务
</span>        <span class="c1"># 同步进程池
</span>        <span class="n">pool</span><span class="o">.</span><span class="nb">apply</span><span class="p">(</span><span class="n">copy</span><span class="p">)</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</code></pre></div></div>

<h3 id="步骤">步骤：</h3>
<ol>
  <li>创建进程池</li>
  <li>加入任务</li>
  <li>告诉主线程等待子线程</li>
</ol>

<h3 id="同步异步">同步/异步</h3>
<ol>
  <li>第一种方案：apply()：同步进程池
     - 问题：就是变成了单线程：🍎平时工作不用</li>
</ol>

<p><img src="/assets/mdimg/屏幕快照 2018-12-21 下午2.50.02.png" alt="" /></p>

<ol>
  <li>第二种方案：apply_async()：异步需要进行等待
    <ul>
      <li>问题：主进程会直接结束</li>
      <li>解决：下面两个必须写
        <ul>
          <li>pool.close():告诉主进程我不在添加其他任务了</li>
          <li>pool.join() :让我们的主进程等等（等待）</li>
        </ul>
      </li>
      <li>解决之后会多个进程一起跑</li>
    </ul>
  </li>
</ol>

<h3 id="进程的注意点">进程的注意点</h3>
<ol>
  <li>主进程会等待子进程结束而结束
 🥔主线程代码执行结束，会等待子进程结束，才会结束子进程</li>
  <li>销毁子进程</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 关闭进程
</span><span class="n">terminate</span><span class="p">()</span>  <span class="c1"># 关闭进程
</span>	
<span class="c1"># 打印PID
</span><span class="k">print</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">())</span>  <span class="c1"># 打印pid
</span>	
<span class="c1"># 进程是由哪个进程创建的
</span><span class="k">print</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">ppid</span><span class="p">())</span>
</code></pre></div></div>

<h4 id="命令行杀死进程">🍎命令行杀死进程</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ps -aux 查看进程
$ ps -aus | grep "python" ：查看python名称的程序
$ kill -9 PID ：杀死进程
- 如果直接杀死主进程，所有子进程也会停止
</code></pre></div></div>

<h4 id="拓展-1">拓展：</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ os.system("ls") # 查看所在目录所有文件
$ os.system("mkdir AAA")  # 创建一个文件夹
$ os.system("kill -9 PID")  # 杀死一个进程
思考；能不能查看本地正在播放的音乐的音乐名称和歌手
</code></pre></div></div>

<h4 id="进程与线程的区别">进程与线程的区别</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 两者都能完成多任务
2. 进程是操作系统分配资源的单位
3. 线程是cpu调度的单位
4. 进程不共享全局变量
5. 线程共享全局变量
6. 进程使用内存比线程大
</code></pre></div></div>

<h4 id="作业-1">作业：</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;文件夹的复制copy&gt;
1. 新建文件夹
2. 得到目录
3. 打开目录
4. 打开文件
5. 读取文件
6. 写到另外一个位置
7. 使用循环
8. 如何让性能提高，使用多任务
9. 写多任务之前先写单任务
</code></pre></div></div>

<h2 id="协程">协程</h2>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>单词收集：
1. spawn：大量产卵/孵化
</code></pre></div></div>

<h3 id="协程代码实现">协程代码实现</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 跳舞
# 1. 导入
# 2. 加入任务
# 3. 等待
</span>
<span class="c1"># 1.导入
</span><span class="k">def</span> <span class="nf">dance</span><span class="p">():</span>
	<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
		<span class="k">print</span><span class="p">(</span><span class="s">"跳舞“）</span><span class="err">
</span><span class="s">		</span><span class="err">
</span><span class="s">def main():</span><span class="err">
</span><span class="s">	"""</span><span class="err">协程</span><span class="s">"""	
	# 2. 加入任务
	spawn_dance = gevent.spawn(dance)
	
	# 3. join()-------&gt;等待
	spawn_dance.join()

-------------------------------------
</span></code></pre></div></div>

<h3 id="协程靠解释器切换只要遇到耗时的就会自动切换如果代码不耗时就不会自动切换">协程靠解释器切换:只要遇到耗时的就会自动切换，如果代码不耗时就不会自动切换</h3>
<ul>
  <li>
    <p>切换方法1：</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  import gevent
  -----------------
  gevent.sleep(时间)
</code></pre></div>    </div>
  </li>
  <li>
    <p>切换方法2:</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1"># 导入
</span>  <span class="kn">import</span> <span class="nn">gevent</span>
  <span class="c1"># 请猴子
</span>  <span class="kn">from</span> <span class="nn">gevent</span> <span class="kn">import</span> <span class="n">monkey</span>
	
  <span class="c1"># 打补丁:打补丁以后就可以使用time.sleep()
</span>  <span class="n">monkey</span><span class="o">.</span><span class="n">patch_all</span><span class="p">()</span>
	
  <span class="c1"># 使用time.sleep()
</span>  <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">()</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>🍅🍅注意不能直接使用time.sleep()</p>
  </li>
  <li>
    <p>切换方法3:</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1"># 创建一个空列表
</span>  <span class="n">spawn_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
  <span class="o">.........................</span>
  <span class="c1"># 加入列表中
</span>  <span class="n">spawn_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="err">函数名</span><span class="p">)</span>
  <span class="o">.........................</span>
  <span class="c1"># 等待列表
</span>  <span class="n">gevent</span><span class="o">.</span><span class="n">joinall</span><span class="p">(</span><span class="n">spawn_list</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="协程使用的步骤">协程使用的步骤</h3>
<ol>
  <li>导入</li>
  <li>请猴子打补丁</li>
  <li>加入到任务列表中</li>
  <li>等待列表</li>
</ol>

<h3 id="协程传参">协程传参</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 传参：第一个是任务，第二个及以后都是参数
</span><span class="n">gevent</span><span class="o">.</span><span class="n">spawn</span><span class="p">(</span><span class="err">函数名，</span><span class="s">"参数1“，”参数2“......"</span><span class="err">参数</span><span class="n">n</span><span class="s">")</span><span class="err">
</span></code></pre></div></div>

<h3 id="协程是在线程里面的">🍅🍅协程是在线程里面的</h3>
<ul>
  <li>关系
    <ul>
      <li>一个程序开启就有一个进程，一个进程自带一个线程，线程中包含协程</li>
    </ul>
  </li>
</ul>

<section class="post-comments">
  
    <div id="disqus_thread"></div>
    <script>
    
    var disqus_config = function () {
        this.page.url = "http://localhost:4000/2018/12/Pyhton-%E9%AB%98%E7%BA%A7/";
        this.page.identifier = "/2018/12/Pyhton-%E9%AB%98%E7%BA%A7/";
    };

    var disqus_shortname = 'vno-jekyll';
    
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();
    </script>
    <noscript>要查看<a href="http://disqus.com/?ref_noscript"> Disqus </a>评论，请启用 JavaScript</noscript>
    
  
  
  
  
</section>


  </section>
</article>

<section class="read-more">
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">最近的文章</span>
       <h2 class="post-list__post-title post-title"><a href="/2018/12/Pyhton-%E7%AE%97%E6%B3%95/" title="link to 算法">算法</a></h2>
       <p class="excerpt">算法（更新中）概念简述算法（Algorithm）是基于特定的计算模型旨在解决某一信息处理问题而设计的一个指令序列不正式地说，算法是任何定义明确的计算过程该过程取某个值或值的集合作为输入并产生某个值或值的集合作为输出算法就是这样的把输入转换成输出的计算步骤的一个序列。必备特征      算法必须具有以下特征：      输入：待计算问题的任一实例，都需要以某种方式交给对应的算法，对所求解问题特定实例的这种描述统称为输入；  输出：经计算和处理之后得到的信息，即针对输入问题实例的答案，称作输出...&hellip;</p>
       <div class="post-list__meta"><time datetime="2018-12-25 09:21:32 +0800" class="post-list__meta--date date">2018-12-25</time> &#8226; <span class="post-list__meta--tags tags">python 算法</span><a class="btn-border-small" href=/2018/12/Pyhton-%E7%AE%97%E6%B3%95/>继续阅读</a></div>
   </div>
   
   
   
</section>

<section class="post-comments">
  
    <div id="disqus_thread"></div>
    <script>
    
    var disqus_config = function () {
        this.page.url = "http://localhost:4000/2018/12/Pyhton-%E9%AB%98%E7%BA%A7/";
        this.page.identifier = "/2018/12/Pyhton-%E9%AB%98%E7%BA%A7/";
    };

    var disqus_shortname = 'vno-jekyll';
    
    (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();
    </script>
    <noscript>要查看<a href="http://disqus.com/?ref_noscript"> Disqus </a>评论，请启用 JavaScript</noscript>
    
  
  
  
  
</section>


            <section class="footer">
    <footer>
    	<span class="footer__copyright">本站点采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a></span>
        <span class="footer__copyright">由 <a href="https://jekyllrb.com">Jekyll</a> 于 2019-03-02 生成，感谢 <a href="https://www.digitalocean.com/?refcode=30ed2d146762">Digital Ocean</a> 为本站提供稳定的 VPS 服务</span>
        <span class="footer__copyright">本站由 <a href="https://github.com/CriseLYJ">@Crise-LYJ</a> 创建，采用 <a href="https://github.com/CriseLYJ/criselyj.github.io">Genius</a> 作为主题，您可以在 GitHub 找到<a href="https://github.com/CriseLYJ/criselyj.github.io">本站源码</a> - &copy; 2019</span>
    </footer>
</section>

        </div>
    </div>
    
    <script type="text/javascript" src="//code.jquery.com/jquery-1.11.3.min.js"></script>

<script type="text/javascript" src="/js/main.js"></script>



    
  </body>

</html>
